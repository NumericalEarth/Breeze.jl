# # Mountain waves with open boundaries
#
# This example simulates mountain waves generated by flow over topography.
# Air flowing over a hill creates internal gravity waves that propagate
# upward and downstream. This classic atmospheric dynamics problem
# demonstrates several features:
#
# - Open boundary conditions using `PerturbationAdvection`
# - Immersed boundary grids with partial cells for topography
# - Sponge layer to absorb waves near the top boundary

using Breeze
using Oceananigans.Grids: ImmersedBoundaryGrid, PartialCellBottom, minimum_xspacing, znode
using Oceananigans.Units
using Printf
using CairoMakie

# ## Domain and topography
#
# We set up a tall, wide domain to allow wave propagation.
# The topography is a Gaussian hill modulated by a cosine function,
# creating a corrugated ridge.

Nx, Nz = 128, 256
H = 20kilometers

underlying_grid = RectilinearGrid(CPU(); size = (Nx, Nz), halo = (4, 4),
                                  x = (-2H, 4H), z = (0, H),
                                  topology = (Bounded, Flat, Bounded))

h₀ = 1000            # maximum hill height (m)
a = 5kilometers      # hill width scale
λ = 4kilometers      # corrugation wavelength

hill(x) = h₀ * exp(-(x / a)^2) * cos(π * x / λ)^2
grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(hill))

# ## Open boundary conditions
#
# Open boundaries allow flow to enter and exit the domain naturally.
# The `PerturbationAdvection` scheme advects perturbations out of the
# domain while maintaining the background flow.

Uᵢ = 10  # background velocity (m/s)
Δx = minimum_xspacing(grid)
τ = 10 * Δx / Uᵢ  # relaxation timescale

reference_state = ReferenceState(grid)
ρᵣ = reference_state.density
scheme = PerturbationAdvection(outflow_timescale=τ, inflow_timescale=τ)
open_bc = OpenBoundaryCondition(ρᵣ * Uᵢ; scheme)
boundary_conditions = (; ρu = FieldBoundaryConditions(west=open_bc, east=open_bc))

# ## Sponge layer
#
# A sponge layer at the top of the domain absorbs upward-propagating waves,
# preventing spurious reflections. The damping rate follows a Gaussian profile
# centered at the top boundary.

δ = 5kilometers  # sponge layer width
γ₀ = 0.01        # maximum damping rate (1/s)

@inline γ(z, H, δ, γ₀) = γ₀ * exp(-((H - z) / δ)^2)

@inline function ρu_sponge(i, j, k, grid, clock, fields, p)
    z = znode(i, j, k, grid, Center(), Center(), Center())
    ρᵣ = @inbounds p.ρᵣ[i, j, k]
    ρu = @inbounds fields.ρu[i, j, k]
    return -γ(z, p.H, p.δ, p.γ₀) * (ρu - ρᵣ * p.Uᵢ)
end

@inline function ρw_sponge(i, j, k, grid, clock, fields, p)
    z = znode(i, j, k, grid, Center(), Center(), Face())
    ρw = @inbounds fields.ρw[i, j, k]
    return -γ(z, p.H, p.δ, p.γ₀) * ρw
end

# Build a temporary model to get the reference density
tmp_model = AtmosphereModel(grid; advection=WENO(), boundary_conditions)
ρᵣ = tmp_model.formulation.reference_state.density
sponge_params = (; H, δ, γ₀, Uᵢ, ρᵣ)

ρu_forcing = Forcing(ρu_sponge, discrete_form=true, parameters=sponge_params)
ρw_forcing = Forcing(ρw_sponge, discrete_form=true, parameters=sponge_params)
forcing = (; ρu=ρu_forcing, ρw=ρw_forcing)

model = AtmosphereModel(grid; advection=WENO(), boundary_conditions, forcing)

# ## Initial conditions
#
# We initialize with uniform horizontal flow and a stably-stratified
# atmosphere. The Brunt-Väisälä frequency ``N² = 10^{-4} \, \mathrm{s}^{-2}``
# supports internal gravity waves.

θ₀ = model.formulation.reference_state.potential_temperature
g = model.thermodynamic_constants.gravitational_acceleration
N² = 1e-4 # Brunt-Väisälä frequency squared (s⁻²)

θᵢ(x, z) = θ₀ * exp(N² * z / g)
set!(model, θ=θᵢ, u=Uᵢ)

# ## Simulation
#
# Run the simulation for 1 hour, saving velocity fields every minute.

simulation = Simulation(model; Δt=1, stop_time=1hour)
conjure_time_step_wizard!(simulation, cfl=0.7)

wall_clock = Ref(time_ns())

function progress(sim)
    elapsed = 1e-9 * (time_ns() - wall_clock[])
    msg = @sprintf("Iter: %d, time: %s, wall time: %s, max|w|: %6.3e m/s\n",
                   iteration(sim), prettytime(sim), prettytime(elapsed),
                   maximum(abs, sim.model.velocities.w))
    wall_clock[] = time_ns()
    @info msg
    return nothing
end

add_callback!(simulation, progress, name=:progress, IterationInterval(100))

filename = "mountain_waves"
simulation.output_writers[:fields] = JLD2Writer(model, model.velocities; filename,
                                                schedule = TimeInterval(1minute),
                                                overwrite_existing = true)

run!(simulation)

# ## Visualization
#
# Create an animation showing the evolution of horizontal and vertical
# velocity. The wave pattern develops as the flow adjusts to the topography.

uts = FieldTimeSeries(filename * ".jld2", "u")
wts = FieldTimeSeries(filename * ".jld2", "w")
times = uts.times
Nt = length(times)

# Compute colorbar limits from final state
ulims = (-2, 14)
wlims = maximum(abs, wts[Nt]) .* (-1, 1)

fig = Figure(size=(900, 600))

axu = Axis(fig[1, 1], aspect=3, xlabel="x (m)", ylabel="z (m)", title="Eastward velocity u (m/s)")
axw = Axis(fig[2, 1], aspect=3, xlabel="x (m)", ylabel="z (m)", title="Vertical velocity w (m/s)")

n = Observable(1)

un = @lift uts[$n]
wn = @lift wts[$n]

hmu = heatmap!(axu, un, colormap=:balance, colorrange=ulims)
hmw = heatmap!(axw, wn, colormap=:curl, colorrange=wlims)

Colorbar(fig[1, 2], hmu)
Colorbar(fig[2, 2], hmw)

title = @lift "Mountain waves at t = " * prettytime(times[$n])
Label(fig[0, :], title, fontsize=20)

record(fig, "mountain_wave.mp4", 1:Nt, framerate=12) do i
    n[] = i
end
nothing #hide

# ![](mountain_wave.mp4)
